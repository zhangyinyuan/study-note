# 16 算法

## N皇后

![07e03076699f9e27a54b6867d7ed423](../../../images/07e03076699f9e27a54b6867d7ed423.png)

### 非递归

```c
// 标准输入输出流
#include <math.h>
#include <stdio.h>

// 定义1个N x N的棋盘
// 这是一个宏定义，属于C语言的预处理指令
// 代码中所有出现 N 的地方都会被替换为 4
// 不可修改,调试的时候,看不到N(替换后符号消失)
// 定义1个标识符, 常量 4. 表示4个皇后
#define N 10

// 定义了一个名为 q 的整型数组
// 由于N=4,所以数组的大小为5
// 存储皇后的列号
int q[N + 1];

// 检查第j个皇后的位置是否合法
// 由于不同的皇后不会放在同一行,所以不用判断行
// 只需要判断两个皇后不在同一列并且不在一条斜线上, 即认为当前皇后的位置合法;反之不合法
// j表示当前正在摆放的第j个皇后
int check(int j) {
    // 如果当前皇后和它之前的每一个皇后相比,
    // 在同一行或者同一个斜线上,认为位置不合法,否则对比完它之前的所有皇后之后,位置都是合法的, 则认为位置合法
    for (int i = 1; i < j; ++i) {
        if (q[i] == q[j] || abs(i - j) == abs(q[i] - q[j])) {
            // 表示在同一列或者同一个斜线上.位置不合法
            return 0;
        }
    }
    return 1;
}

// 求解N皇后的方案
void queue() {
    // 从1开始,q[i]表示第i个皇后
    for (int i = 1; i <= N; ++i) {
        q[i] = 0; // 把每个皇后的列都定义为0,表示全都没有放入棋盘.反之>0,比如q[i] = 1,表示第1个皇后放在了第一行的第一列
    }

    // 方案数
    int answer = 0;

    // 表示正在摆放第j个皇后
    int j = 1;
    // i <=N 表示要摆放N个皇后
    while (j >= 1) {
        // 表示将第j个皇后,向右移动1个位置.
        // 初始的时候,表示将第1个皇后从棋盘外(q[0]移动到第一行的第1列)
        q[j]++;

        while (q[j] <= N && !check(j)) {
            // 这里必须要加上=N,如果不加.就会少一个越界的场景.导致由于越界后需要调整上一个皇后位置的场景丢失.最终导致数据错乱
            q[j] = q[j] + 1;
        }

        if (q[j] <= N) {
            if (j == N) { // 找到了N皇后的一组解
                answer++;
                printf("方案%d:  ", answer);
                for (int i = 1; i <= N; ++i) {
                    printf("%d,", q[i]);
                }
                printf("\n");
            } else {
                // 继续摆放下一个皇后的位置
                j++;
            }
        } else {
            // 越界,回溯
            q[j] = 0;
            j--;
        }
    }
}

int main(int argc, char const *argv[]) {
    queue();

    return 0;
}
```



## 递归

```c
#include <math.h>
#include <stdio.h>

#define N 3

int answer = 0;

// 定义1个一维数组
// 假设有4个皇后, 每个皇后占1行,
// j从1开始, 下标j表示第j个皇后,q[j]的值表示皇后的位置列.所以1个皇后的位置可以表示为 j,q[j].
// 即第j个皇后在第j行的第q[j]列
int q[N + 1];

/**
 * 检查当前皇后的位置是否合法
 * @param j 从1开始,表示当前正在被摆放的皇后的位置列
 * @return 1 表示合法;0表示不合法
 */
int check(int j) {
    for (int i = 1; i < j; i++) {
        // 当前摆放的皇后的列和以往的每一个皇后在同一列,则认为不合法;
        // 或者
        // 当当前皇后的行号-每一个皇后的行号的绝对值等于两个皇后的列号的绝对值,同样认为不合法
        if (q[i] == q[j] || abs(i - j) == abs(q[i] - q[j])) {
            return 0;
        }
    }
    return 1;
}

/**
 * 求解N皇后问题
 */
void queue(int j) {
    q[j] = q[j] +1;
    for (int i = 1; i <= N; ++i) {
        q[j] = i;
        if (check(j)) {
            if (j == N ) {
                //找到一组N皇后解
                answer++;
                printf("方案%d:  ", answer);
                for (int i = 1; i <=N ; ++i) {
                    printf("%d, ", q[i]);
                }
                printf("\n");
            } else {
                queue(j + 1);
            }
        }
    }
}

int main() {
    for (int j = 1; j <= N; ++j) {
        q[j] = 0;
    }

    // 一开始将第一个皇后放入到第一行的第一列
    queue(1);
    return 0;
}
```

