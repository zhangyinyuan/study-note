# 上午题 #6 数据库

![image-20250323082500609](../../../images/image-20250323082500609.png)

---

## 三级模式

![image-20250323083139628](../../../images/image-20250323083139628.png)

---

## 两级映像

> 注意： 就只有两级。不存在其他，比如外到内

（1）**模式/内模式的映像**。存在于概念级和内部级之间，实现了概念模式到内模式之间的相互转换。
（2）**外模式/模式的映像**。存在于外部级和概念级之间，实现了外模式到概念模式之间的相互转换。

![image-20250323083627392](../../../images/image-20250323083627392.png)

---

![image-20250323085014896](../../../images/image-20250323085014896.png)

---

## 关系代数表达式

![image-20250323161114659](../../../images/image-20250323161114659.png)

---

![image-20250323162058621](../../../images/image-20250323162058621.png)

---

![image-20250323163408163](../../../images/image-20250323163408163.png)

---



![image-20250323164438434](../../../images/image-20250323164438434.png)

---

![image-20250323165023831](../../../images/image-20250323165023831.png)

---

>  注意: **^ 是并且的意思. σ2>'7'表示的是第2列的值大于7**

![image-20250323170357594](../../../images/image-20250323170357594.png)

---

![image-20250323184414152](../../../images/image-20250323184414152-1742808923984-1.png)

---

![image-20250323195648307](../../../images/image-20250323195648307.png)

---

## 连接

### 经典题型-自然连接

自然连接前的关系是, 进行自然连接后(已经去掉了重复列),从1开始数.最后投影

![image-20250324222740603](../../../images/image-20250324222740603.png)

---

### 经典题型-笛卡尔积

![image-20250324225248757](../../../images/image-20250324225248757.png)

---

## SQL控制语句

![image-20250324232843126](../../../images/image-20250324232843126.png)

---

## 视图

![image-20250324233246338](../../../images/image-20250324233246338.png)

---

![image-20250324233620516](../../../images/image-20250324233620516.png)

---

## 候选关键字/主属性/非主属性

### 详细分析

给定关系模式R<U,F>，U={A,B,C,D}，F={AB→C,C→B}。关系R有几个候选关键字,且分别有哪些主属性和非主属性?

1. **关系模式 R<U, F>**：这里 U 是属性的集合 {A, B, C, D}，F 是函数依赖的集合 {AB→C, C→B}。
2. **候选关键字（Candidate Key）**：能唯一标识关系中元组的最小属性集合。即，候选关键字的闭包包含所有属性 U，且其任何真子集的闭包都不能包含所有属性。
3. **主属性（Prime Attribute）**：属于任何一个候选关键字的属性。
4. **非主属性（Non-Prime Attribute）**：不属于任何候选关键字的属性。

#### 寻找候选关键字

为了找到所有的候选关键字，我们需要找出所有属性集的最小组合，其闭包能覆盖所有属性 {A, B, C, D}。我们可以从单个属性开始，逐步增加属性，直到找到满足条件的组合。

##### 1. 计算单个属性的闭包

- {A}+：
  - 初始：A
  - 无法通过 F 中的函数依赖扩展，因为没有以 A 为左侧的依赖。
  - {A}+ = {A} ≠ U
- {B}+：
  - 初始：B
  - 无法通过 F 扩展。
  - {B}+ = {B} ≠ U
- {C}+：
  - 初始：C
  - 使用 C→B：{C, B}
  - 无法进一步扩展。
  - {C}+ = {B, C} ≠ U
- {D}+：
  - 初始：D
  - 无法扩展。
  - {D}+ = {D} ≠ U

单个属性都无法覆盖所有属性，因此需要尝试多个属性的组合。

##### 2. 尝试两个属性的组合

- {A, B}+：
  - 初始：A, B
  - 使用 AB→C：{A, B, C}
  - 使用 C→B：已经在集合中。
  - 无法进一步扩展。
  - {A, B}+ = {A, B, C} ≠ U （缺少 D）
- {A, C}+：
  - 初始：A, C
  - 使用 C→B：{A, B, C}
  - 使用 AB→C：已经在集合中。
  - 无法进一步扩展。
  - {A, C}+ = {A, B, C} ≠ U
- {A, D}+：
  - 初始：A, D
  - 无法直接应用任何函数依赖。
  - {A, D}+ = {A, D} ≠ U
- {B, C}+：
  - 初始：B, C
  - 使用 C→B：已经在集合中。
  - 无法进一步扩展。
  - {B, C}+ = {B, C} ≠ U
- {B, D}+：
  - 初始：B, D
  - 无法应用函数依赖。
  - {B, D}+ = {B, D} ≠ U
- {C, D}+：
  - 初始：C, D
  - 使用 C→B：{B, C, D}
  - 无法进一步扩展。
  - {C, D}+ = {B, C, D} ≠ U （缺少 A）

两个属性的组合都无法覆盖所有属性，需要尝试三个属性。

##### 3. 尝试三个属性的组合

- {A, B, D}+：

  - 初始：A, B, D
  - 使用 AB→C：{A, B, C, D} = U
  - 已经覆盖所有属性。
  - {A, B, D}+ = {A, B, C, D} = U

  这是一个超键，需要检查是否可以去掉某个属性仍能覆盖 U。

  - 检查 {A, D}+ = {A, D} ≠ U
  - 检查 {B, D}+ = {B, D} ≠ U
  - 检查 {A, B}+ = {A, B, C} ≠ U

  无法去掉任何属性，因此 {A, B, D} 是一个候选关键字。

- {A, C, D}+：

  - 初始：A, C, D
  - 使用 C→B：{A, B, C, D} = U
  - {A, C, D}+ = U

  检查是否可以去掉某个属性：

  - {A, D}+ = {A, D} ≠ U
  - {C, D}+ = {B, C, D} ≠ U
  - {A, C}+ = {A, B, C} ≠ U

  无法去掉任何属性，因此 {A, C, D} 也是一个候选关键字。

- 其他三个属性的组合：

  - {A, B, C}+：
    - 初始：A, B, C
    - 使用 AB→C 和 C→B 已经包含。
    - {A, B, C}+ = {A, B, C} ≠ U （缺少 D）
  - {B, C, D}+：
    - 初始：B, C, D
    - 使用 C→B 已经包含。
    - {B, C, D}+ = {B, C, D} ≠ U （缺少 A）

  这些组合不能覆盖 U。

##### 4. 尝试四个属性的组合

- {A, B, C, D}：
  - 这是一个超键，但不是最小的，因为已经有更小的组合 {A, B, D} 和 {A, C, D} 可以覆盖 U。
  - 因此，{A, B, C, D} 不是候选关键字。

##### 5. 检查是否有其他候选关键字

我们需要确认是否还有其他两个或三个属性的组合可以覆盖 U。

- 我们已经检查了所有两个属性的组合，都无法覆盖 U。
- 对于三个属性，只有 {A, B, D} 和 {A, C, D} 可以覆盖 U，且都是最小的。

因此，候选关键字有两个：{A, B, D} 和 {A, C, D}。

#### 确定主属性和非主属性

- **主属性**：出现在至少一个候选关键字中的属性。**包括在候选关键字中的属性都是主属性,反之是非主属性**
  - {A, B, D} 和 {A, C, D} 中的属性有：A, B, C, D。
    - A 出现在两个候选关键字中。
    - B 出现在 {A, B, D} 中。
    - C 出现在 {A, C, D} 中。
    - D 出现在两个候选关键字中。
  - 因此，所有属性 A, B, C, D 都是主属性。
- **非主属性**：**不属于任何候选关键字的属性**。
  - 这里没有非主属性。

---

![image-20250325002754876](../../../images/image-20250325002754876.png)

---

![image-20250325220924860](../../../images/image-20250325220924860.png)

---

![image-20250325221444297](../../../images/image-20250325221444297.png)

---

![image-20250325222322241](../../../images/image-20250325222322241.png)

---

## 三范式

### 1NF

特点: 每个属性是原子的, 不可再分的 

**存在的问题**: 存在冗余,存在修改,插入,删除不一致的异常,需要分解

### 2NF

特点: 不存在非主属性对候选码的部分函数依赖.或者说每个非主属性完全依赖主键(主属性)

存在的问题: 

### 3NF

消除: 消除传递依赖

存在:

### BCNF



### 4NF

---

![image-20250326204705596](../../../images/image-20250326204705596.png)

---

![image-20250326203534266](../../../images/image-20250326203534266.png)

---

![image-20250326204959832](../../../images/image-20250326204959832.png)

---

![image-20250326210738714](../../../images/image-20250326210738714.png)

---

![image-20250326211330365](../../../images/image-20250326211330365.png)

---

## 关系分解



![image-20250326212437869](../../../images/image-20250326212437869.png)

---

![image-20250326213331013](../../../images/image-20250326213331013.png)

---

## 无损连接和保持函数依赖

![image-20250326214014846](../../../images/image-20250326214014846.png)

---

![image-20250326215414871](../../../images/image-20250326215414871.png)

---

## 复合属性与多值属性

### 典型例子及本质区别

---

#### 多值

> 多个属性是独立的, 去掉任何一个也是完整的

##### 1个人有多个电话号码

- 同一属性"电话号码",有多个独立的值
- 号码之间是并且关系.无上下级关系
- 每个号码可以单独使用,也可以多选
- 任意号码可以新增/删除/修改.属性仍然保持完整性

##### 1个人有多个电子邮箱

##### 1个人有多个技能

![image-20250329120239506](../../../images/image-20250329120239506.png)

---

#### 复合

> 多个属性之间需要组合才能表达完整意义

**例子**：姓氏("张") + 名字("三")

##### 完整姓名

- 由姓氏和名字组合成完整姓名
- 子属性有明确语义关系
- 组合后才有完整意义

##### 地址

**例子**：中国+北京市+海淀区+中关村南大街5号

- 由多级行政区划组成
- 子属性有层级关系
- 组合后形成完整地址

##### 身份证号码

**例子**：110105+19900307+3721+X

- 由地区码、生日码、顺序码、校验码组成
- 各部分有特定编码规则
- 组合后才有唯一标识意义

##### 产品规格

**例子**：手机=屏幕(6.1")+CPU(A15)+内存(8GB)
**分析**：

- 由多个技术参数组成
- 子属性共同描述产品
- 缺一不可完整描述

---

![image-20250326232529145](../../../images/image-20250326232529145.png)

---

## 分E-R图冲突有3类

> 这有这3种,没有其他

### 属性冲突

属性的类型、取值范围、取值单位等不一致

### 命名冲突

不同的命名在不同的分E-R图中表达的意思是同一个

### 结构冲突

同一个实体在不同的E-R图中有不同的属性,同一个对象在某个E-R图中被抽象为实体, 在某个E-R图中又被抽象为属性

### **关键区分技巧**

- **属性冲突**: **定义或取值规则不一致**（不是名字问题，也不是属性缺失问题）

- **命名冲突**：**叫法不同**,纠结“叫什么名字”（比如该叫职工号还是教师号？）。
- **结构冲突**：**属性集合定义不同**, 纠结“该有哪些属性”（为什么人力部门不记录职称？教学部门不记录性别？）

![image-20250326235918805](../../../images/image-20250326235918805.png)

---

### **三者的终极区分技巧**

| 冲突类型     | 问题焦点                       | 判断关键词             | 示例                   |
| :----------- | :----------------------------- | :--------------------- | :--------------------- |
| **属性冲突** | 属性的数据类型或取值规则不一致 | “类型不同”“格式不同”   | 职工号：整数 vs 字符串 |
| **命名冲突** | 属性或实体名称不统一           | “名字不同”“叫法不一致” | 职工号 vs 工号         |
| **结构冲突** | 同一实体的属性集合不一致       | “缺少属性”“多出属性”   | 人力无职称，教学无性别 |

## 数据库设计阶段与规范化

**先问需求定边界，再画E-R概念清；**
**逻辑转表规范化，物理存得快又稳。**

| **阶段**     | **核心任务**                         | **关键输出**                     |
| :----------- | :----------------------------------- | :------------------------------- |
| **需求分析** | 确定系统边界、收集业务规则和数据需求 | 需求说明文档、数据字典、数据流图 |
| **概念设计** | 建立抽象模型（如E-R图）              | E-R图、概念模型                  |
| **逻辑设计** | 将概念模型转为关系模型，并进行规范化 | 关系模式（表结构）、范式化       |
| **物理设计** | 优化存储结构（索引、分区等）         | 物理存储方案、SQL调优            |

![image-20250329092418511](../../../images/image-20250329092418511.png)

---

**程序文档是开发人员根据设计结果编写代码后的产物**。不属于数据库设计阶段

![image-20250329095811238](../../../images/image-20250329095811238.png)

---

![image-20250329100741107](../../../images/image-20250329100741107.png)

---

## 共享锁(S)和排他锁(X)

#### S锁与S锁兼容

- **S锁**可以**同时被不同的事务加锁成功**
- S锁被当前事务添加成功后,此时当前事务对当前数据添加X锁,
  - 如果同时没有被其他事务添加S锁,此时**S锁升级为X锁, 添加X锁成功**
  - 如果**同时被其他事务添加了S锁**,那么**添加X锁失败**

#### X锁与其他锁完全冲突

- **X锁被某一事务添加成功后, 其他事务无法对当前事务添加任何锁**,直到X锁释放
- **同一事务**添加X锁成功后, **再次添加X锁**,数据库会跳过冲突检查,**不会真正重复加锁,但是也不会报错**
- 当前数据已经被事务添加了S锁,其他事务请求添加X锁,添加不成功

![image-20250329104040552](../../../images/image-20250329104040552.png)

---

## 分布式数据库

![image-20250329115206441](../../../images/image-20250329115206441.png)

---

![image-20250329115752078](../../../images/image-20250329115752078.png)

---

## Armstrong公理系统

![image-20250329122246427](../../../images/image-20250329122246427.png)

---

## 数据库函数格式

![image-20250329122548811](../../../images/image-20250329122548811.png)

---

![image-20250329122836427](../../../images/image-20250329122836427.png)



